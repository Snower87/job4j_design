#task_04 (#04), 06.11.21:
 * @Раздел Блок 2.1. Структуры данных и алгоритмы / 2.1.1. Iterator
 * @Задание 1. Что такое итератор. [#4951]
 * @Описание 1. Реализуйте итератор для массива. Итератор должен отдавать элементы в обратном порядке.
 *  2. Напишите тесты. Протестируйте код в junit.
 *  3. Загрузите код в github. Оставьте ссылку на коммит.
=============================================================================================
#task_05 (#05), 07.11.21:
  * @Задание Устранение ошибок в п.1. Что такое итератор. [#4951] (ver.2)
=============================================================================================
#task_06 (#06), 08.11.21:
 * @Раздел Блок 2.1. Структуры данных и алгоритмы / 2.1.1. Iterator
 * @Задание 5.1.1. Итератор для двухмерного массива int[][] [#9539]
 * @Описание 1. Реализуйте методы next и hasNext для перебора элементов двумерного массива.
 * Так как у нас может быть ситуация когда в массиве есть много пустых массивов, то для
 * оптимизации можно сделать чтобы hasNext() устанавливал указатель на нужный элемент.
 * Нужно с помощью чисел row и column двигать указатель.
 * Добавлять новые поля в класс MatrixIt не нужно.
 * Копировать двухмерный в одномерный массив не нужно. Это не верное решение.
 *  2. Протестируйте код в junit.
 *  3. Загрузите код в github. Оставьте ссылку на коммит.
=============================================================================================
#task_07 (#07), 09.11.21:
 * @Раздел Блок 2.1. Структуры данных и алгоритмы / 2.1.1. Iterator
 * @Задание 5.1.2. Создать итератор четные числа [#150]
 * @Описание 1. Создать итератор возвращающий только четные цифры.
 * 2. Требования к реализации методов:
 * - метод next в случае отсутствия элементов к возврату генерирует NoSuchElementException.
 * - метод next должен возвращать верные значения вне зависимости от того вызвал ли перед этим
 *   программист метод hasNext. Аналогично для hasNext. Результат работы ваших методов не должен зависеть
 *   от последовательности в которой программист вызывает методы, т.е. не полагайтесь на то, что программист будет
 *   вызывать методы именно в том порядке в котором вы ожидаете.
 * - не допускайте дублирования кода. Если вы видите, что методы next и hasNext имеют одинаковый код, то выносите этот код
 *   в отдельный метод и делайте уже его вызов.
 * - не используйте эксепшены для управления логикой вашей программы. Они созданы для обработки критических ситуаций +
 *   очень дороги в создании по сравнению с обычными объектами в Java.
 * - не оставляйте пустых методов в коде. Обратите внимание, что метод remove объявлен как дефолтный - это значит,
 *   что нет необходимости его реализовывать пустым, если вы не собираетесь переопределять его поведение.
 *   В коде не должно быть пустых методов, если ваша программа не поддерживает какой-либо функционал задекларированный
 *   в интерфейсе - прокидывайте UnsupportedOperationException.
 *  3. Протестируйте код в junit.
 *  4. Загрузите код в github. Оставьте ссылку на коммит.
========================================================================================================
#task_08 (#08), 09.11.21:
  * @Задание Устранение ошибок в п.5.1.1. Итератор для двухмерного массива int[][] [#9539] (ver.2)
========================================================================================================
#task_09 (#09), 09.11.21:
  * @Задание Устранение ошибок в п.5.1.1. Итератор для двухмерного массива int[][] [#9539] (ver.3)
========================================================================================================
#task_10 (#10), 10.11.21:
  * @Задание Устранение ошибок в п.5.1.2. Создать итератор четные числа [#150] (ver.2)
========================================================================================================
#task_11 (#11), 10.11.21:
  * @Задание Устранение ошибок в п.5.1.1. Итератор для двухмерного массива int[][] [#9539] (ver.4)
========================================================================================================
#task_12 (#12), 10.11.21:
  * @Задание Устранение ошибок в п.5.1.2. Создать итератор четные числа [#150] (ver.3)
========================================================================================================
#task_13 (#13), 11.11.21:
  * @Задание Устранение ошибок в п.5.1.1. Итератор для двухмерного массива int[][] [#9539] (ver.5)
========================================================================================================
#task_14 (#14), 11.11.21:
  * @Задание Устранение ошибок в п.5.1.2. Создать итератор четные числа [#150] (ver.4)
========================================================================================================
#task_15 (#15), 11.11.21:
 * @Раздел Блок 2.1. Структуры данных и алгоритмы / 2.1.1. Iterator
 * @Задание 5.1.4. FlatMap для Iterator<Iterator> [#152]
 * @Описание 1. Класс FlatMap принимает объект вложенных итераторов.
 * В классе нужно реализовать два метода: next и hasNext.
 * Метод next должен последовательно вернуть числа из вложенных итераторов.
 * В этом задании нельзя копировать элементы во временный список.
 * 2. Протестируйте код в junit.
 * 3. Загрузите код в github. Оставьте ссылку на коммит.
========================================================================================================
#task_16 (#16), 16.11.21:
 * @Раздел Блок 2.1. Структуры данных и алгоритмы / 2.1.2. Generic
 * @Задание 0. Что такое обобщенные типы (generics) [#4952]
 * @Описание 1. Добавьте 3 модели данных, которые образуют иерархию наследования: Animal - Predator - Tiger.
 * 2. Код содержит ошибки компиляции, вам необходимо их поправить, закомментировав строки которые их вызывают. При этом:
 * 1-ый метод - работает без ограничений, т.е. в него можно передавать коллекцию, которая хранит любые типы.
 * 2-ой метод - должен иметь ограничение сверху и ограничиваться классом Predator.
 * 3-ий метод - должен иметь ограничение снизу и ограничиваться классом Predator.
 * 3. Загрузите код в github. Оставьте ссылку на коммит.
========================================================================================================
#task_17 (#17), 17.11.21:
  * @Задание Устранение ошибок в п.0. Что такое обобщенные типы (generics) [#4952] (ver.2)
========================================================================================================
#task_18 (#18), 17.11.21:
  * @Задание Устранение ошибок в п.0. Что такое обобщенные типы (generics) [#4952] (ver.3)
========================================================================================================
#task_19 (#19), 18.11.21:
 * @Раздел Блок 2.1. Структуры данных и алгоритмы / 2.1.2. Generic
 * @Задание 5.2.2. Реализовать Store<T extends Base> [#157]
 * @Описание 1. Реализуйте методы в классе MemStore. Все модели наследуются от базовой модели ru.job4j.generic.Base.
 * 2. Реализуйте методы в классе UserStore.
 * 3. Создайте и реализуйте класс RoleStore.
 * 4. Загрузите код в github. Оставьте ссылку на коммит.
========================================================================================================
#task_20 (#20), 18.11.21:
  * @Задание Устранение ошибок в п.5.2.2. Реализовать Store<T extends Base> [#157] (ver.2)
========================================================================================================
#task_21 (#21), 27.11.21:
 * @Раздел Блок 2.1. Структуры данных и алгоритмы / 2.1.3. List
 * @Задание 1. Динамический список на массиве. [#158]
 * @Описание 1. Реализовать динамический массив на базе собственного интерфейса List<T>.
 * Требования к программе:
 * 1) Внутри контейнер должен базироваться на массиве Object[] container.
 * 2) Использовать стандартные коллекции JDK (ArrayList, LinkedList и т.д.) запрещено.
 * 3) Контейнер должен быть динамическим, т.е. при полном заполнении увеличиваться. Увеличивать надо массив в два раза.
 * 4) Итератор должен реализовывать fail-fast поведение, т.е. если с момента создания итератора в коллекцию добавили
 *    новый элемент, итератор должен кидать ConcurrentModificationException.
 * 5) В методах, где используется индекс нужно делать валидацию. Индекс должен находиться в рамках добавленных элементов.
 *    Для проверки индекса используйте метод Objects.checkIndex()
 * 6) Для удаления нужно использовать метод System.arraycopy().
 * 7) Итератор должен кидать два исключения:
 * 7.1) NoSuchElementException. Относится к первому показателю - количеству элементов.
 *      Если итератор "уперся", т.е. нет больше элементов, а клиент вызвал этот метод, то этим исключение мы ему
 *      подчеркиваем, что элементов больше нет.
 * 7.2) ConcurrentModificationException. Относится ко второму показателю - числу модификаций. Чтобы кинуть это исключение
 *      заводят отдельную переменную в итераторе expectedModCount = modCount и проверяют условие if (expectedModCount != modCount).
        Если условие выполнено, значит на момент итерирования была изменена коллекция, поэтому вылетает исключение. Это fail-fast поведение.
 * 2. Протестируйте код в junit.
 * 3. Загрузите код в github. Оставьте ссылку на коммит.
========================================================================================================